{
    "language": "Solidity",
    "sources": {
        "./contracts/mocks/MockBlockHeaderMerkleParts.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport {\n    BlockHeaderMerkleParts\n} from \"../bridge/library/BlockHeaderMerkleParts.sol\";\n\ncontract MockBlockHeaderMerkleParts {\n    function getBlockHeader(\n        BlockHeaderMerkleParts.Data memory _self,\n        bytes32 _appHash\n    ) public pure returns (bytes32) {\n        return BlockHeaderMerkleParts.getBlockHeader(_self, _appHash);\n    }\n}\n"
        },
        "./contracts/mocks/MockTMSignature.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport {TMSignature} from \"../bridge/library/TMSignature.sol\";\n\ncontract MockTMSignature {\n    function recoverSigner(TMSignature.Data memory _data, bytes32 _blockHash)\n        public\n        pure\n        returns (address)\n    {\n        return TMSignature.recoverSigner(_data, _blockHash);\n    }\n}\n"
        },
        "./contracts/bridge/library/TMSignature.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.6.0;\n\n/// @dev Library for performing signer recovery for ECDSA secp256k1 signature. Note that the\n/// library is written specifically for signature signed on Tendermint's precommit data, which\n/// includes the block hash and some additional information prepended and appended to the block\n/// hash. The prepended part (prefix) and the appended part (suffix) are different for each signer\n/// (including signature size, machine clock, validator index, etc).\nlibrary TMSignature {\n    struct Data {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        bytes signedDataPrefix;\n        bytes signedDataSuffix;\n    }\n\n    /// @dev Returns the address that signed on the given block hash.\n    /// @param blockHash The block hash that the validator signed data on.\n    function recoverSigner(Data memory self, bytes32 blockHash)\n        internal\n        pure\n        returns (address)\n    {\n        return\n            ecrecover(\n                sha256(\n                    abi.encodePacked(\n                        self.signedDataPrefix,\n                        blockHash,\n                        self.signedDataSuffix\n                    )\n                ),\n                self.v,\n                self.r,\n                self.s\n            );\n    }\n}\n"
        },
        "./contracts/mocks/MockIAVLMerklePath.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport {IAVLMerklePath} from \"../bridge/library/IAVLMerklePath.sol\";\n\ncontract MockIAVLMerklePath {\n    function getParentHash(\n        IAVLMerklePath.Data memory _self,\n        bytes32 _dataSubtreeHash\n    ) public pure returns (bytes32) {\n        return IAVLMerklePath.getParentHash(_self, _dataSubtreeHash);\n    }\n}\n"
        },
        "./contracts/bridge/library/IAVLMerklePath.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.6.0;\nimport {Utils} from \"./Utils.sol\";\n\n/// @dev Library for computing iAVL Merkle root from (1) data leaf and (2) a list of \"MerklePath\"\n/// from such leaf to the root of the tree. Each Merkle path (i.e. proof component) consists of:\n///\n/// - isDataOnRight: whether the data is on the right subtree of this internal node.\n/// - subtreeHeight: well, it is the height of this subtree.\n/// - subtreeVersion: the latest block height that this subtree has been updated.\n/// - siblingHash: 32-byte hash of the other child subtree\n///\n/// To construct a hash of an internal Merkle node, the hashes of the two subtrees are combined\n/// with extra data of this internal node. See implementation below. Repeatedly doing this from\n/// the leaf node until you get to the root node to get the final iAVL Merkle hash.\nlibrary IAVLMerklePath {\n    struct Data {\n        bool isDataOnRight;\n        uint8 subtreeHeight;\n        uint256 subtreeSize;\n        uint256 subtreeVersion;\n        bytes32 siblingHash;\n    }\n\n    /// @dev Returns the upper Merkle hash given a proof component and hash of data subtree.\n    /// @param dataSubtreeHash The hash of data subtree up until this point.\n    function getParentHash(Data memory self, bytes32 dataSubtreeHash)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 leftSubtree = self.isDataOnRight\n            ? self.siblingHash\n            : dataSubtreeHash;\n        bytes32 rightSubtree = self.isDataOnRight\n            ? dataSubtreeHash\n            : self.siblingHash;\n        return\n            sha256(\n                abi.encodePacked(\n                    self.subtreeHeight << 1, // Tendermint signed-int8 encoding requires multiplying by 2\n                    Utils.encodeVarintSigned(self.subtreeSize),\n                    Utils.encodeVarintSigned(self.subtreeVersion),\n                    uint8(32), // Size of left subtree hash\n                    leftSubtree,\n                    uint8(32), // Size of right subtree hash\n                    rightSubtree\n                )\n            );\n    }\n}\n"
        },
        "./contracts/bridge/library/Utils.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.6.0;\n\n/// @dev Helper utility library for calculating Merkle proof and managing bytes.\nlibrary Utils {\n    /// @dev Returns the hash of a Merkle leaf node.\n    function merkleLeafHash(bytes memory value)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return sha256(abi.encodePacked(uint8(0), value));\n    }\n\n    /// @dev Returns the hash of internal node, calculated from child nodes.\n    function merkleInnerHash(bytes32 left, bytes32 right)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return sha256(abi.encodePacked(uint8(1), left, right));\n    }\n\n    /// @dev Returns the encoded bytes using signed varint encoding of the given input.\n    function encodeVarintSigned(uint256 value)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return encodeVarintUnsigned(value * 2);\n    }\n\n    /// @dev Returns the encoded bytes using unsigned varint encoding of the given input.\n    function encodeVarintUnsigned(uint256 value)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        // Computes the size of the encoded value.\n        uint256 tempValue = value;\n        uint256 size = 0;\n        while (tempValue > 0) {\n            ++size;\n            tempValue >>= 7;\n        }\n        // Allocates the memory buffer and fills in the encoded value.\n        bytes memory result = new bytes(size);\n        tempValue = value;\n        for (uint256 idx = 0; idx < size; ++idx) {\n            result[idx] = bytes1(uint8(128) | uint8(tempValue & 127));\n            tempValue >>= 7;\n        }\n        result[size - 1] &= bytes1(uint8(127)); // Drop the first bit of the last byte.\n        return result;\n    }\n\n    /// @dev Returns the encoded bytes follow how tendermint encode time.\n    function encodeTime(uint64 second, uint32 nanoSecond)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = abi.encodePacked(\n            hex\"08\",\n            encodeVarintUnsigned(uint256(second))\n        );\n        if (nanoSecond > 0) {\n            result = abi.encodePacked(\n                result,\n                hex\"10\",\n                encodeVarintUnsigned(uint256(nanoSecond))\n            );\n        }\n        return result;\n    }\n}\n"
        },
        "./contracts/mocks/MockResultDecoder.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.6.0;\n\nimport \"../obi/Obi.sol\";\n\nlibrary MockResultDecoder {\n    using Obi for Obi.Data;\n\n    struct Result {\n        string symbol;\n        uint64 multiplier;\n        uint8 what;\n    }\n\n    function decodeResult(bytes memory _data)\n        internal\n        pure\n        returns (Result memory result)\n    {\n        Obi.Data memory decoder = Obi.from(_data);\n        result.symbol = string(decoder.decodeBytes());\n        result.multiplier = decoder.decodeU64();\n        result.what = decoder.decodeU8();\n        require(decoder.finished(), \"DATA_DECODE_NOT_FINISHED\");\n    }\n}\n"
        },
        "./contracts/obi/Obi.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nlibrary Obi {\n    using SafeMath for uint256;\n\n    struct Data {\n        uint256 offset;\n        bytes raw;\n    }\n\n    function from(bytes memory data) internal pure returns (Data memory) {\n        return Data({offset: 0, raw: data});\n    }\n\n    modifier shift(Data memory data, uint256 size) {\n        require(data.raw.length >= data.offset + size, \"Obi: Out of range\");\n        _;\n        data.offset += size;\n    }\n\n    function finished(Data memory data) internal pure returns (bool) {\n        return data.offset == data.raw.length;\n    }\n\n    function decodeU8(Data memory data)\n        internal\n        pure\n        shift(data, 1)\n        returns (uint8 value)\n    {\n        value = uint8(data.raw[data.offset]);\n    }\n\n    function decodeI8(Data memory data)\n        internal\n        pure\n        shift(data, 1)\n        returns (int8 value)\n    {\n        value = int8(data.raw[data.offset]);\n    }\n\n    function decodeU16(Data memory data) internal pure returns (uint16 value) {\n        value = uint16(decodeU8(data)) << 8;\n        value |= uint16(decodeU8(data));\n    }\n\n    function decodeI16(Data memory data) internal pure returns (int16 value) {\n        value = int16(decodeI8(data)) << 8;\n        value |= int16(decodeI8(data));\n    }\n\n    function decodeU32(Data memory data) internal pure returns (uint32 value) {\n        value = uint32(decodeU16(data)) << 16;\n        value |= uint32(decodeU16(data));\n    }\n\n    function decodeI32(Data memory data) internal pure returns (int32 value) {\n        value = int32(decodeI16(data)) << 16;\n        value |= int32(decodeI16(data));\n    }\n\n    function decodeU64(Data memory data) internal pure returns (uint64 value) {\n        value = uint64(decodeU32(data)) << 32;\n        value |= uint64(decodeU32(data));\n    }\n\n    function decodeI64(Data memory data) internal pure returns (int64 value) {\n        value = int64(decodeI32(data)) << 32;\n        value |= int64(decodeI32(data));\n    }\n\n    function decodeU128(Data memory data)\n        internal\n        pure\n        returns (uint128 value)\n    {\n        value = uint128(decodeU64(data)) << 64;\n        value |= uint128(decodeU64(data));\n    }\n\n    function decodeI128(Data memory data) internal pure returns (int128 value) {\n        value = int128(decodeI64(data)) << 64;\n        value |= int128(decodeI64(data));\n    }\n\n    function decodeU256(Data memory data)\n        internal\n        pure\n        returns (uint256 value)\n    {\n        value = uint256(decodeU128(data)) << 128;\n        value |= uint256(decodeU128(data));\n    }\n\n    function decodeI256(Data memory data) internal pure returns (int256 value) {\n        value = int256(decodeI128(data)) << 128;\n        value |= int256(decodeI128(data));\n    }\n\n    function decodeBool(Data memory data) internal pure returns (bool value) {\n        value = (decodeU8(data) != 0);\n    }\n\n    function decodeBytes(Data memory data)\n        internal\n        pure\n        returns (bytes memory value)\n    {\n        value = new bytes(decodeU32(data));\n        for (uint256 i = 0; i < value.length; i++) {\n            value[i] = bytes1(decodeU8(data));\n        }\n    }\n\n    function decodeString(Data memory data)\n        internal\n        pure\n        returns (string memory value)\n    {\n        return string(decodeBytes(data));\n    }\n\n    function decodeBytes32(Data memory data)\n        internal\n        pure\n        shift(data, 32)\n        returns (bytes1[32] memory value)\n    {\n        bytes memory raw = data.raw;\n        uint256 offset = data.offset;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            mstore(value, mload(add(add(raw, 32), offset)))\n        }\n    }\n\n    function decodeBytes64(Data memory data)\n        internal\n        pure\n        shift(data, 64)\n        returns (bytes1[64] memory value)\n    {\n        bytes memory raw = data.raw;\n        uint256 offset = data.offset;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            mstore(value, mload(add(add(raw, 32), offset)))\n            mstore(add(value, 32), mload(add(add(raw, 64), offset)))\n        }\n    }\n\n    function decodeBytes65(Data memory data)\n        internal\n        pure\n        shift(data, 65)\n        returns (bytes1[65] memory value)\n    {\n        bytes memory raw = data.raw;\n        uint256 offset = data.offset;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            mstore(value, mload(add(add(raw, 32), offset)))\n            mstore(add(value, 32), mload(add(add(raw, 64), offset)))\n        }\n        value[64] = data.raw[data.offset + 64];\n    }\n}\n"
        },
        "./contracts/mocks/BridgeData.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport {Bridge} from \"../bridge/Bridge.sol\";\nimport {IBridge} from \"../../interfaces/bridge/IBridge.sol\";\n\ncontract BridgeData {\n    Bridge public bridge;\n    IBridge.RequestPacket public req;\n    IBridge.ResponsePacket public res;\n\n    constructor(Bridge _bridge) public {\n        bridge = _bridge;\n    }\n\n    function relayAndSave(bytes calldata data) external {\n        (\n            IBridge.RequestPacket memory _req,\n            IBridge.ResponsePacket memory _res\n        ) = bridge.relayAndVerify(data);\n\n        req = _req;\n        res = _res;\n    }\n\n    function requestClientID() external view returns (string memory) {\n        return req.clientID;\n    }\n\n    function oracleScriptID() external view returns (uint64) {\n        return req.oracleScriptID;\n    }\n\n    function params() external view returns (bytes memory) {\n        return req.params;\n    }\n\n    function askCount() external view returns (uint64) {\n        return req.askCount;\n    }\n\n    function minCount() external view returns (uint64) {\n        return req.minCount;\n    }\n\n    function responseClientID() external view returns (string memory) {\n        return res.clientID;\n    }\n\n    function requestID() external view returns (uint64) {\n        return res.requestID;\n    }\n\n    function ansCount() external view returns (uint64) {\n        return res.ansCount;\n    }\n\n    function requestTime() external view returns (uint64) {\n        return res.requestTime;\n    }\n\n    function resolveTime() external view returns (uint64) {\n        return res.resolveTime;\n    }\n\n    function resolveStatus() external view returns (uint8) {\n        return res.resolveStatus;\n    }\n\n    function result() external view returns (bytes memory) {\n        return res.result;\n    }\n}\n"
        },
        "./contracts/bridge/Bridge.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport {BlockHeaderMerkleParts} from \"./library/BlockHeaderMerkleParts.sol\";\nimport {MultiStore} from \"./library/MultiStore.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IAVLMerklePath} from \"./library/IAVLMerklePath.sol\";\nimport {TMSignature} from \"./library/TMSignature.sol\";\nimport {Utils} from \"./library/Utils.sol\";\nimport {Packets} from \"./library/Packets.sol\";\nimport {IBridge} from \"../../interfaces/bridge/IBridge.sol\";\n\n/// @title BandChain Bridge\n/// @author Band Protocol Team\ncontract Bridge is IBridge, Ownable {\n    using BlockHeaderMerkleParts for BlockHeaderMerkleParts.Data;\n    using MultiStore for MultiStore.Data;\n    using IAVLMerklePath for IAVLMerklePath.Data;\n    using TMSignature for TMSignature.Data;\n    using SafeMath for uint256;\n\n    struct ValidatorWithPower {\n        address addr;\n        uint256 power;\n    }\n\n    struct BlockDetail {\n        bytes32 oracleState;\n        uint64 timeSecond;\n        uint32 timeNanoSecond;\n    }\n\n    /// Mapping from block height to the struct that contains block time and hash of \"oracle\" iAVL Merkle tree.\n    mapping(uint256 => BlockDetail) public blockDetails;\n    /// Mapping from an address to its voting power.\n    mapping(address => uint256) public validatorPowers;\n    /// The total voting power of active validators currently on duty.\n    uint256 public totalValidatorPower;\n\n    /// Initializes an oracle bridge to BandChain.\n    /// @param validators The initial set of BandChain active validators.\n    constructor(ValidatorWithPower[] memory validators) public {\n        for (uint256 idx = 0; idx < validators.length; ++idx) {\n            ValidatorWithPower memory validator = validators[idx];\n            require(\n                validatorPowers[validator.addr] == 0,\n                \"DUPLICATION_IN_INITIAL_VALIDATOR_SET\"\n            );\n            validatorPowers[validator.addr] = validator.power;\n            totalValidatorPower = totalValidatorPower.add(validator.power);\n        }\n    }\n\n    /// Update validator powers by owner.\n    /// @param validators The changed set of BandChain validators.\n    function updateValidatorPowers(ValidatorWithPower[] memory validators)\n        external\n        onlyOwner\n    {\n        for (uint256 idx = 0; idx < validators.length; ++idx) {\n            ValidatorWithPower memory validator = validators[idx];\n            totalValidatorPower = totalValidatorPower.sub(\n                validatorPowers[validator.addr]\n            );\n            validatorPowers[validator.addr] = validator.power;\n            totalValidatorPower = totalValidatorPower.add(validator.power);\n        }\n    }\n\n    /// Relays a detail of Bandchain block to the bridge contract.\n    /// @param multiStore Extra multi store to compute app hash. See MultiStore lib.\n    /// @param merkleParts Extra merkle parts to compute block hash. See BlockHeaderMerkleParts lib.\n    /// @param signatures The signatures signed on this block, sorted alphabetically by address.\n    function relayBlock(\n        MultiStore.Data memory multiStore,\n        BlockHeaderMerkleParts.Data memory merkleParts,\n        TMSignature.Data[] memory signatures\n    ) public {\n        bytes32 appHash = multiStore.getAppHash();\n        // Computes Tendermint's block header hash at this given block.\n        bytes32 blockHeader = merkleParts.getBlockHeader(appHash);\n        // Counts the total number of valid signatures signed by active validators.\n        address lastSigner = address(0);\n        uint256 sumVotingPower = 0;\n        for (uint256 idx = 0; idx < signatures.length; ++idx) {\n            address signer = signatures[idx].recoverSigner(blockHeader);\n            require(signer > lastSigner, \"INVALID_SIGNATURE_SIGNER_ORDER\");\n            sumVotingPower = sumVotingPower.add(validatorPowers[signer]);\n            lastSigner = signer;\n        }\n        // Verifies that sufficient validators signed the block and saves the oracle state.\n        require(\n            sumVotingPower.mul(3) > totalValidatorPower.mul(2),\n            \"INSUFFICIENT_VALIDATOR_SIGNATURES\"\n        );\n        blockDetails[merkleParts.height] = BlockDetail({\n            oracleState: multiStore.oracleIAVLStateHash,\n            timeSecond: merkleParts.timeSecond,\n            timeNanoSecond: merkleParts.timeNanoSecond\n        });\n    }\n\n    /// Helper struct to workaround Solidity's \"stack too deep\" problem.\n    struct VerifyOracleDataLocalVariables {\n        bytes encodedVarint;\n        bytes32 dataHash;\n    }\n\n    /// Verifies that the given data is a valid data on BandChain as of the relayed block height.\n    /// @param blockHeight The block height. Someone must already relay this block.\n    /// @param requestPacket The request packet is this request.\n    /// @param responsePacket The response packet of this request.\n    /// @param version Lastest block height that the data node was updated.\n    /// @param merklePaths Merkle proof that shows how the data leave is part of the oracle iAVL.\n    function verifyOracleData(\n        uint256 blockHeight,\n        RequestPacket memory requestPacket,\n        ResponsePacket memory responsePacket,\n        uint256 version,\n        IAVLMerklePath.Data[] memory merklePaths\n    ) public view returns (RequestPacket memory, ResponsePacket memory) {\n        bytes32 oracleStateRoot = blockDetails[blockHeight].oracleState;\n        require(\n            oracleStateRoot != bytes32(uint256(0)),\n            \"NO_ORACLE_ROOT_STATE_DATA\"\n        );\n        // Computes the hash of leaf node for iAVL oracle tree.\n        VerifyOracleDataLocalVariables memory vars;\n        vars.encodedVarint = Utils.encodeVarintSigned(version);\n        vars.dataHash = sha256(\n            Packets.getEncodedResult(requestPacket, responsePacket)\n        );\n        bytes32 currentMerkleHash = sha256(\n            abi.encodePacked(\n                uint8(0), // Height of tree (only leaf node) is 0 (signed-varint encode)\n                uint8(2), // Size of subtree is 1 (signed-varint encode)\n                vars.encodedVarint,\n                uint8(9), // Size of data key (1-byte constant 0x01 + 8-byte request ID)\n                uint8(255), // Constant 0xff prefix data request info storage key\n                responsePacket.requestID,\n                uint8(32), // Size of data hash\n                vars.dataHash\n            )\n        );\n        // Goes step-by-step computing hash of parent nodes until reaching root node.\n        for (uint256 idx = 0; idx < merklePaths.length; ++idx) {\n            currentMerkleHash = merklePaths[idx].getParentHash(\n                currentMerkleHash\n            );\n        }\n        // Verifies that the computed Merkle root matches what currently exists.\n        require(\n            currentMerkleHash == oracleStateRoot,\n            \"INVALID_ORACLE_DATA_PROOF\"\n        );\n\n        return (requestPacket, responsePacket);\n    }\n\n    /// Performs oracle state relay and oracle data verification in one go. The caller submits\n    /// the encoded proof and receives back the decoded data, ready to be validated and used.\n    /// @param data The encoded data for oracle state relay and data verification.\n    function relayAndVerify(bytes calldata data)\n        external\n        override\n        returns (RequestPacket memory, ResponsePacket memory)\n    {\n        (bytes memory relayData, bytes memory verifyData) = abi.decode(\n            data,\n            (bytes, bytes)\n        );\n        (bool relayOk, ) = address(this).call(\n            abi.encodePacked(this.relayBlock.selector, relayData)\n        );\n        require(relayOk, \"RELAY_BLOCK_FAILED\");\n        (bool verifyOk, bytes memory verifyResult) = address(this).staticcall(\n            abi.encodePacked(this.verifyOracleData.selector, verifyData)\n        );\n        require(verifyOk, \"VERIFY_ORACLE_DATA_FAILED\");\n        return abi.decode(verifyResult, (RequestPacket, ResponsePacket));\n    }\n\n    /// Performs oracle state relay and many times of oracle data verification in one go. The caller submits\n    /// the encoded proof and receives back the decoded data, ready to be validated and used.\n    /// @param data The encoded data for oracle state relay and an array of data verification.\n    function relayAndMultiVerify(bytes calldata data)\n        external\n        override\n        returns (RequestPacket[] memory, ResponsePacket[] memory)\n    {\n        (bytes memory relayData, bytes[] memory manyVerifyData) = abi.decode(\n            data,\n            (bytes, bytes[])\n        );\n        (bool relayOk, ) = address(this).call(\n            abi.encodePacked(this.relayBlock.selector, relayData)\n        );\n        require(relayOk, \"RELAY_BLOCK_FAILED\");\n\n        RequestPacket[] memory requests = new RequestPacket[](\n            manyVerifyData.length\n        );\n        ResponsePacket[] memory responses = new ResponsePacket[](\n            manyVerifyData.length\n        );\n        for (uint256 i = 0; i < manyVerifyData.length; i++) {\n            (bool verifyOk, bytes memory verifyResult) = address(this)\n                .staticcall(\n                abi.encodePacked(\n                    this.verifyOracleData.selector,\n                    manyVerifyData[i]\n                )\n            );\n            require(verifyOk, \"VERIFY_ORACLE_DATA_FAILED\");\n            (requests[i], responses[i]) = abi.decode(\n                verifyResult,\n                (RequestPacket, ResponsePacket)\n            );\n        }\n\n        return (requests, responses);\n    }\n}\n"
        },
        "./contracts/bridge/library/BlockHeaderMerkleParts.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.6.0;\nimport {Utils} from \"./Utils.sol\";\n\n/// @dev Library for computing Tendermint's block header hash from app hash, time, and height.\n///\n/// In Tendermint, a block header hash is the Merkle hash of a binary tree with 14 leaf nodes.\n/// Each node encodes a data piece of the blockchain. The notable data leaves are: [A] app_hash,\n/// [2] height, and [3] - time. All data pieces are combined into one 32-byte hash to be signed\n/// by block validators. The structure of the Merkle tree is shown below.\n///\n///                                   [BlockHeader]\n///                                /                \\\n///                   [3A]                                    [3B]\n///                 /      \\                                /      \\\n///         [2A]                [2B]                [2C]                [2D]\n///        /    \\              /    \\              /    \\              /    \\\n///    [1A]      [1B]      [1C]      [1D]      [1E]      [1F]        [C]    [D]\n///    /  \\      /  \\      /  \\      /  \\      /  \\      /  \\\n///  [0]  [1]  [2]  [3]  [4]  [5]  [6]  [7]  [8]  [9]  [A]  [B]\n///\n///  [0] - version               [1] - chain_id            [2] - height        [3] - time\n///  [4] - last_block_id         [5] - last_commit_hash    [6] - data_hash     [7] - validators_hash\n///  [8] - next_validators_hash  [9] - consensus_hash      [A] - app_hash      [B] - last_results_hash\n///  [C] - evidence_hash         [D] - proposer_address\n///\n/// Notice that NOT all leaves of the Merkle tree are needed in order to compute the Merkle\n/// root hash, since we only want to validate the correctness of [A], [2], and [3]. In fact, only\n/// [1A], [2B], [1E], [B], and [2D] are needed in order to compute [BlockHeader].\nlibrary BlockHeaderMerkleParts {\n    struct Data {\n        bytes32 versionAndChainIdHash; // [1A]\n        uint64 height; // [2]\n        uint64 timeSecond; // [3]\n        uint32 timeNanoSecond; // [3]\n        bytes32 lastBlockIDAndOther; // [2B]\n        bytes32 nextValidatorHashAndConsensusHash; // [1E]\n        bytes32 lastResultsHash; // [B]\n        bytes32 evidenceAndProposerHash; // [2D]\n    }\n\n    /// @dev Returns the block header hash after combining merkle parts with necessary data.\n    /// @param appHash The Merkle hash of BandChain application state.\n    function getBlockHeader(Data memory self, bytes32 appHash)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            Utils.merkleInnerHash( // [BlockHeader]\n                Utils.merkleInnerHash( // [3A]\n                    Utils.merkleInnerHash( // [2A]\n                        self.versionAndChainIdHash, // [1A]\n                        Utils.merkleInnerHash( // [1B]\n                            Utils.merkleLeafHash( // [2]\n                                Utils.encodeVarintUnsigned(self.height)\n                            ),\n                            Utils.merkleLeafHash( // [3]\n                                Utils.encodeTime(\n                                    self.timeSecond,\n                                    self.timeNanoSecond\n                                )\n                            )\n                        )\n                    ),\n                    self.lastBlockIDAndOther // [2B]\n                ),\n                Utils.merkleInnerHash( // [3B]\n                    Utils.merkleInnerHash( // [2C]\n                        self.nextValidatorHashAndConsensusHash, // [1E]\n                        Utils.merkleInnerHash( // [1F]\n                            Utils.merkleLeafHash( // [A]\n                                abi.encodePacked(uint8(32), appHash)\n                            ),\n                            self.lastResultsHash // [B]\n                        )\n                    ),\n                    self.evidenceAndProposerHash // [2D]\n                )\n            );\n    }\n}\n"
        },
        "./contracts/bridge/library/MultiStore.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.6.0;\nimport {Utils} from \"./Utils.sol\";\n\n// Computes Tendermint's application state hash at this given block. AppHash is actually a\n// Merkle hash on muliple stores.\n//                         ________________[AppHash]_______________\n//                        /                                        \\\n//             _______[I9]______                          ________[I10]________\n//            /                  \\                       /                     \\\n//       __[I5]__             __[I6]__              __[I7]__               __[I8]__\n//      /         \\          /         \\           /         \\            /         \\\n//    [I1]       [I2]     [I3]        [I4]       [8]        [9]          [A]        [B]\n//   /   \\      /   \\    /    \\      /    \\\n// [0]   [1]  [2]   [3] [4]   [5]  [6]    [7]\n// [0] - acc      [1] - distr   [2] - evidence  [3] - gov\n// [4] - main     [5] - mint    [6] - oracle    [7] - params\n// [8] - slashing [9] - staking [A] - supply    [D] - upgrade\n// Notice that NOT all leaves of the Merkle tree are needed in order to compute the Merkle\n// root hash, since we only want to validate the correctness of [6] In fact, only\n// [7], [I3], [I5], and [I10] are needed in order to compute [AppHash].\n\nlibrary MultiStore {\n    struct Data {\n        bytes32 accToGovStoresMerkleHash; // [I5]\n        bytes32 mainAndMintStoresMerkleHash; // [I3]\n        bytes32 oracleIAVLStateHash; // [6]\n        bytes32 paramsStoresMerkleHash; // [7]\n        bytes32 slashingToUpgradeStoresMerkleHash; // [I10]\n    }\n\n    function getAppHash(Data memory self) internal pure returns (bytes32) {\n        return\n            Utils.merkleInnerHash( // [AppHash]\n                Utils.merkleInnerHash( // [I9]\n                    self.accToGovStoresMerkleHash, // [I5]\n                    Utils.merkleInnerHash( // [I6]\n                        self.mainAndMintStoresMerkleHash, // [I3]\n                        Utils.merkleInnerHash(\n                            Utils.merkleLeafHash( // [I4]\n                                abi.encodePacked( // [6]\n                                    hex\"066f7261636c6520\", // oracle prefix (uint8(6) + \"oracle\" + uint8(32))\n                                    sha256(\n                                        abi.encodePacked(\n                                            sha256(\n                                                abi.encodePacked(\n                                                    self.oracleIAVLStateHash\n                                                )\n                                            )\n                                        )\n                                    )\n                                )\n                            ),\n                            self.paramsStoresMerkleHash // [7]\n                        )\n                    )\n                ),\n                self.slashingToUpgradeStoresMerkleHash // [I10]\n            );\n    }\n}\n"
        },
        "./contracts/bridge/library/Packets.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport {Utils} from \"./Utils.sol\";\nimport {IBridge} from \"../../../interfaces/bridge/IBridge.sol\";\n\nlibrary Packets {\n    function encodeRequestPacket(IBridge.RequestPacket memory self)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return\n            abi.encodePacked(\n                uint32(bytes(self.clientID).length),\n                self.clientID,\n                self.oracleScriptID,\n                uint32(self.params.length),\n                self.params,\n                self.askCount,\n                self.minCount\n            );\n    }\n\n    function encodeResponsePacket(IBridge.ResponsePacket memory self)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return\n            abi.encodePacked(\n                uint32(bytes(self.clientID).length),\n                self.clientID,\n                self.requestID,\n                self.ansCount,\n                self.requestTime,\n                self.resolveTime,\n                uint32(self.resolveStatus),\n                uint32(bytes(self.result).length),\n                self.result\n            );\n    }\n\n    function getEncodedResult(\n        IBridge.RequestPacket memory req,\n        IBridge.ResponsePacket memory res\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                encodeRequestPacket(req),\n                encodeResponsePacket(res)\n            );\n    }\n\n    /// Returns the hash of a RequestPacket.\n    /// @param request A tuple that represents RequestPacket struct.\n    function getRequestKey(IBridge.RequestPacket memory request)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(request));\n    }\n}\n"
        },
        "./interfaces/bridge/IBridge.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\ninterface IBridge {\n    /// Request packet struct is similar packet on Bandchain using to re-calculate result hash.\n    struct RequestPacket {\n        string clientID;\n        uint64 oracleScriptID;\n        bytes params;\n        uint64 askCount;\n        uint64 minCount;\n    }\n\n    /// Response packet struct is similar packet on Bandchain using to re-calculate result hash.\n    struct ResponsePacket {\n        string clientID;\n        uint64 requestID;\n        uint64 ansCount;\n        uint64 requestTime;\n        uint64 resolveTime;\n        uint8 resolveStatus;\n        bytes result;\n    }\n\n    /// Performs oracle state relay and oracle data verification in one go. The caller submits\n    /// the encoded proof and receives back the decoded data, ready to be validated and used.\n    /// @param data The encoded data for oracle state relay and data verification.\n    function relayAndVerify(bytes calldata data)\n        external\n        returns (RequestPacket memory, ResponsePacket memory);\n\n    /// Performs oracle state relay and many times of oracle data verification in one go. The caller submits\n    /// the encoded proof and receives back the decoded data, ready to be validated and used.\n    /// @param data The encoded data for oracle state relay and an array of data verification.\n    function relayAndMultiVerify(bytes calldata data)\n        external\n        returns (RequestPacket[] memory, ResponsePacket[] memory);\n}\n"
        },
        "./contracts/mocks/MockPackets.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport {IBridge} from \"../../interfaces/bridge/IBridge.sol\";\nimport {Packets} from \"../bridge/library/Packets.sol\";\n\ncontract MockPackets {\n    function encodeRequestPacket(IBridge.RequestPacket memory _packet)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return Packets.encodeRequestPacket(_packet);\n    }\n\n    function encodeResponsePacket(IBridge.ResponsePacket memory _packet)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return Packets.encodeResponsePacket(_packet);\n    }\n\n    function getEncodedResult(\n        IBridge.RequestPacket memory _req,\n        IBridge.ResponsePacket memory _res\n    ) public pure returns (bytes memory) {\n        return Packets.getEncodedResult(_req, _res);\n    }\n}\n"
        },
        "./contracts/mocks/MockObiUser.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport {Obi} from \"../obi/Obi.sol\";\nimport {MockResultDecoder} from \"./MockResultDecoder.sol\";\n\ncontract MockObiUser {\n    using MockResultDecoder for bytes;\n\n    function decode(bytes memory data)\n        public\n        pure\n        returns (MockResultDecoder.Result memory)\n    {\n        return data.decodeResult();\n    }\n}\n"
        },
        "./contracts/mocks/MockMultiStore.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport {MultiStore} from \"../bridge/library/MultiStore.sol\";\n\ncontract MockMultiStore {\n    function getAppHash(MultiStore.Data memory _self)\n        public\n        pure\n        returns (bytes32)\n    {\n        return MultiStore.getAppHash(_self);\n    }\n}\n"
        },
        "./contracts/mocks/MockBridge.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport {Bridge} from \"../bridge/Bridge.sol\";\nimport {IBridge} from \"../../interfaces/bridge/IBridge.sol\";\n\n/// @dev Mock OracleBridge that allows setting oracle iAVL state at a given height directly.\ncontract MockBridge is Bridge {\n    constructor(ValidatorWithPower[] memory _validators)\n        public\n        Bridge(_validators)\n    {}\n\n    function setOracleState(uint256 _blockHeight, bytes32 _oracleIAVLStateHash)\n        public\n    {\n        blockDetails[_blockHeight].oracleState = _oracleIAVLStateHash;\n    }\n}\n\ncontract MockReceiver {\n    Bridge.RequestPacket public latestReq;\n    Bridge.ResponsePacket public latestRes;\n    Bridge.RequestPacket[] public latestRequests;\n    Bridge.ResponsePacket[] public latestResponses;\n    IBridge public bridge;\n\n    constructor(IBridge _bridge) public {\n        bridge = _bridge;\n    }\n\n    function relayAndSafe(bytes calldata _data) external {\n        (latestReq, latestRes) = bridge.relayAndVerify(_data);\n    }\n\n    function relayAndMultiSafe(bytes calldata _data) external {\n        (\n            Bridge.RequestPacket[] memory requests,\n            Bridge.ResponsePacket[] memory responses\n        ) = bridge.relayAndMultiVerify(_data);\n        delete latestRequests;\n        delete latestResponses;\n        for (uint256 i = 0; i < requests.length; i++) {\n            latestRequests.push(requests[i]);\n            latestResponses.push(responses[i]);\n        }\n    }\n}\n"
        },
        "./contracts/mocks/MockUtils.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.6.0;\nimport {Utils} from \"../bridge/library/Utils.sol\";\n\ncontract MockUtils {\n    function merkleLeafHash(bytes memory value) public pure returns (bytes32) {\n        return Utils.merkleLeafHash(value);\n    }\n\n    function merkleInnerHash(bytes32 left, bytes32 right)\n        public\n        pure\n        returns (bytes32)\n    {\n        return Utils.merkleInnerHash(left, right);\n    }\n\n    function encodeVarintSigned(uint256 _value)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return Utils.encodeVarintSigned(_value);\n    }\n\n    function encodeVarintUnsigned(uint256 _value)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return Utils.encodeVarintUnsigned(_value);\n    }\n\n    function encodeTime(uint64 second, uint32 nanoSecond)\n        public\n        pure\n        returns (bytes memory)\n    {\n        return Utils.encodeTime(second, nanoSecond);\n    }\n}\n"
        },
        "./contracts/bridge/CacheBridge.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport {Packets} from \"./library/Packets.sol\";\nimport {Bridge} from \"./Bridge.sol\";\nimport {ICacheBridge} from \"../../interfaces/bridge/ICacheBridge.sol\";\nimport {IBridge} from \"../../interfaces/bridge/IBridge.sol\";\n\n/// @title BandChain CacheBridge\n/// @author Band Protocol Team\ncontract CacheBridge is Bridge, ICacheBridge {\n    using Packets for IBridge.RequestPacket;\n\n    /// Mapping from hash of RequestPacket to the latest ResponsePacket.\n    mapping(bytes32 => ResponsePacket) public requestsCache;\n\n    /// Initializes an oracle bridge to BandChain by pass the argument to the parent contract (Bridge.sol).\n    /// @param validators The initial set of BandChain active validators.\n    constructor(ValidatorWithPower[] memory validators)\n        public\n        Bridge(validators)\n    {}\n\n    /// Returns the ResponsePacket for a given RequestPacket.\n    /// Reverts if can't find the related response in the mapping.\n    /// @param request A tuple that represents RequestPacket struct.\n    function getLatestResponse(RequestPacket memory request)\n        public\n        override\n        view\n        returns (ResponsePacket memory)\n    {\n        ResponsePacket memory res = requestsCache[request.getRequestKey()];\n        require(res.requestID != 0, \"RESPONSE_NOT_FOUND\");\n\n        return res;\n    }\n\n    /// Save the new ResponsePacket to the state by using hash of its associated RequestPacket,\n    /// provided that the saved ResponsePacket is newer than the one that was previously saved.\n    /// Reverts if the new ResponsePacket is not newer than the current one or not successfully resolved.\n    /// @param request A tuple that represents a RequestPacket struct that associated the new ResponsePacket.\n    /// @param response A tuple that represents a new ResponsePacket struct.\n    function _cacheResponse(\n        RequestPacket memory request,\n        ResponsePacket memory response\n    ) internal {\n        bytes32 requestKey = request.getRequestKey();\n\n        require(\n            response.resolveTime > requestsCache[requestKey].resolveTime,\n            \"FAIL_LATEST_REQUEST_SHOULD_BE_NEWEST\"\n        );\n\n        require(\n            response.resolveStatus == 1,\n            \"FAIL_REQUEST_IS_NOT_SUCCESSFULLY_RESOLVED\"\n        );\n\n        requestsCache[requestKey] = response;\n    }\n\n    /// Performs oracle state relay and oracle data verification in one go.\n    /// After that, the results will be recorded to the state by using the hash of RequestPacket as key.\n    /// @param data The encoded data for oracle state relay and data verification.\n    function relay(bytes calldata data) external override {\n        (RequestPacket memory request, ResponsePacket memory response) = this\n            .relayAndVerify(data);\n\n        _cacheResponse(request, response);\n    }\n\n    /// Performs oracle state relay and many times of oracle data verification in one go.\n    /// After that, the results which is an array of Packet will be recorded to the state by using the hash of RequestPacket as key.\n    /// @param data The encoded data for oracle state relay and an array of data verification.\n    function relayMulti(bytes calldata data) external override {\n        (\n            RequestPacket[] memory requests,\n            ResponsePacket[] memory responses\n        ) = this.relayAndMultiVerify(data);\n\n        for (uint256 i = 0; i < requests.length; i++) {\n            _cacheResponse(requests[i], responses[i]);\n        }\n    }\n}\n"
        },
        "./interfaces/bridge/ICacheBridge.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport {IBridge} from \"./IBridge.sol\";\n\ninterface ICacheBridge is IBridge {\n    /// Returns the ResponsePacket for a given RequestPacket.\n    /// @param request The tuple that represents RequestPacket struct.\n    function getLatestResponse(RequestPacket calldata request)\n        external\n        view\n        returns (ResponsePacket memory);\n\n    /// Performs oracle state relay and oracle data verification in one go.\n    /// After that, the results will be recorded to the state by using the hash of RequestPacket as key.\n    /// @param data The encoded data for oracle state relay and data verification.\n    function relay(bytes calldata data) external;\n\n    /// Performs oracle state relay and many times of oracle data verification in one go.\n    /// After that, the results which is an array of Packet will be recorded to the state by using the hash of RequestPacket as key.\n    /// @param data The encoded data for oracle state relay and an array of data verification.\n    function relayMulti(bytes calldata data) external;\n}\n"
        },
        "./contracts/stdreference/library/StdReferenceDecoder.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\nimport {Obi} from \"../../obi/Obi.sol\";\n\nlibrary StdReferenceDecoder {\n    using Obi for Obi.Data;\n    struct Params {\n        string[] symbols;\n        uint64 multiplier;\n    }\n\n    struct Result {\n        uint64[] rates;\n    }\n\n    function decodeParams(bytes memory _data)\n        internal\n        pure\n        returns (Params memory result)\n    {\n        Obi.Data memory decoder = Obi.from(_data);\n        uint32 length = decoder.decodeU32();\n        string[] memory symbols = new string[](length);\n        for (uint256 i = 0; i < length; i++) {\n            symbols[i] = string(decoder.decodeBytes());\n        }\n        result.symbols = symbols;\n        result.multiplier = decoder.decodeU64();\n        require(decoder.finished(), \"DATA_DECODE_NOT_FINISHED\");\n    }\n\n    function decodeResult(bytes memory _data)\n        internal\n        pure\n        returns (Result memory result)\n    {\n        Obi.Data memory decoder = Obi.from(_data);\n        uint32 length = decoder.decodeU32();\n        uint64[] memory rates = new uint64[](length);\n        for (uint256 i = 0; i < length; i++) {\n            rates[i] = decoder.decodeU64();\n        }\n        result.rates = rates;\n        require(decoder.finished(), \"DATA_DECODE_NOT_FINISHED\");\n    }\n}\n"
        },
        "./contracts/stdreference/StdReferenceProxy.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../interfaces/stdreference/IStdReference.sol\";\n\ncontract StdReferenceProxy is Ownable, StdReferenceBase {\n    IStdReference public ref;\n\n    constructor(IStdReference _ref) public {\n        ref = _ref;\n    }\n\n    /// @notice Updates standard reference implementation. Only callable by the owner.\n    /// @param _ref Address of the new standard reference contract\n    function setRef(IStdReference _ref) public onlyOwner {\n        ref = _ref;\n    }\n\n    /// @notice Returns the price data for the given base/quote pair. Revert if not available.\n    /// @param base The base symbol of the token pair\n    /// @param quote The quote symbol of the token pair\n    function getReferenceData(string memory base, string memory quote)\n        public\n        view\n        override\n        returns (ReferenceData memory)\n    {\n        return ref.getReferenceData(base, quote);\n    }\n}\n"
        },
        "./interfaces/stdreference/IStdReference.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\ninterface IStdReference {\n    /// A structure returned whenever someone requests for standard reference data.\n    struct ReferenceData {\n        uint256 rate; // base/quote exchange rate, multiplied by 1e18.\n        uint256 lastUpdatedBase; // UNIX epoch of the last time when base price gets updated.\n        uint256 lastUpdatedQuote; // UNIX epoch of the last time when quote price gets updated.\n    }\n\n    /// Returns the price data for the given base/quote pair. Revert if not available.\n    function getReferenceData(string memory _base, string memory _quote)\n        external\n        view\n        returns (ReferenceData memory);\n\n    /// Similar to getReferenceData, but with multiple base/quote pairs at once.\n    function getReferenceDataBulk(\n        string[] memory _bases,\n        string[] memory _quotes\n    ) external view returns (ReferenceData[] memory);\n}\n\nabstract contract StdReferenceBase is IStdReference {\n    function getReferenceData(string memory _base, string memory _quote)\n        public\n        virtual\n        override\n        view\n        returns (ReferenceData memory);\n\n    function getReferenceDataBulk(\n        string[] memory _bases,\n        string[] memory _quotes\n    ) public override view returns (ReferenceData[] memory) {\n        require(_bases.length == _quotes.length, \"BAD_INPUT_LENGTH\");\n        uint256 len = _bases.length;\n        ReferenceData[] memory results = new ReferenceData[](len);\n        for (uint256 idx = 0; idx < len; idx++) {\n            results[idx] = getReferenceData(_bases[idx], _quotes[idx]);\n        }\n        return results;\n    }\n}\n"
        },
        "./contracts/stdreference/StdReference.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IBridge} from \"../../interfaces/bridge/IBridge.sol\";\nimport {Obi} from \"../obi/Obi.sol\";\nimport {StdReferenceDecoder} from \"./library/StdReferenceDecoder.sol\";\nimport \"../../interfaces/stdreference/IStdReference.sol\";\n\n/// @title BandChain StdReferenceBasic\n/// @author Band Protocol Team\ncontract StdReference is AccessControl, StdReferenceBase {\n    using Obi for Obi.Data;\n    using SafeMath for uint256;\n\n    IBridge public bridge;\n\n    /// List of valid oracle script IDs\n    uint64[] public oracleScriptIDs;\n\n    /// Mininum number of BandChain validator reports to allow\n    uint64 public ansCount;\n\n    /// Mininum number of BandChain validator reports asked to allow\n    uint64 public askCount;\n\n    /// Duration to wait for challenge before data will be\n    /// available for each symbol\n    uint256 public pendingDuration;\n\n    /// Whether to trust the relayer\n    /// Initially true but will be false if disproved by user.\n    bool public trustRelayer = true;\n\n    // Update event emitted when ref is updated\n    event RefDataUpdate(\n        string symbol,\n        uint64 rate,\n        uint64 resolveTime,\n        uint64 requestID\n    );\n\n    // Update event emitted when pendingRef is updated\n    event PendingRefDataUpdate(\n        string symbol,\n        uint64 rate,\n        uint64 resolveTime,\n        uint64 requestID\n    );\n\n    // Update event emitted from a successful relayWithProof call\n    event VerifiedRefDataUpdate(\n        string symbol,\n        uint64 rate,\n        uint64 resolveTime,\n        uint64 requestID\n    );\n\n    struct RefData {\n        uint64 rate; // USD-rate, multiplied by 1e9.\n        uint64 resolveTime; // UNIX epoch when this data has been resolved.\n        uint64 relayTime; // UNIX epoch when this data has been resolved.\n        uint64 requestID; // BandChain request identifier for this data.\n    }\n\n    /// Mapping from token symbol to ref data\n    /// Updated by relay() after past pendingDuration\n    mapping(string => RefData) public refs;\n\n    /// Mapping from token symbol to pending ref data\n    /// updated by relay()\n    mapping(string => RefData) public pendingRefs;\n\n    /// Mapping from token symbol to verified ref data\n    /// updated by relayWithProof()\n    mapping(string => RefData) public verifiedRefs;\n\n    bytes32 public constant RELAYER_ROLE = keccak256(\"RELAYER_ROLE\");\n\n    constructor(\n        IBridge _bridge,\n        uint64[] memory _oracleScriptIDs,\n        uint64 _askCount,\n        uint64 _ansCount,\n        uint64 _pendingDuration\n    ) public {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(RELAYER_ROLE, msg.sender);\n\n        bridge = _bridge;\n        oracleScriptIDs = _oracleScriptIDs;\n        askCount = _askCount;\n        ansCount = _ansCount;\n        pendingDuration = _pendingDuration;\n    }\n\n    /// @notice Relay and save a set of price data to the contract\n    /// @dev All of the lists must be of equal length\n    /// @param symbols A list of symbols whose data is being relayed in this function call\n    /// @param rates A list of the rates associated with each symbol\n    /// @param resolveTimes A list of timestamps of when the rate data was retrieved\n    /// @param requestIDs A list of BandChain request IDs in which the rate data was retrieved\n    function relay(\n        string[] memory symbols,\n        uint64[] memory rates,\n        uint64[] memory resolveTimes,\n        uint64[] memory requestIDs\n    ) external {\n        require(hasRole(RELAYER_ROLE, msg.sender), \"NOT_A_RELAYER\");\n        uint256 len = symbols.length;\n        require(rates.length == len, \"BAD_RATES_LENGTH\");\n        require(resolveTimes.length == len, \"BAD_RESOLVE_TIMES_LENGTH\");\n        require(requestIDs.length == len, \"BAD_REQUESTIDS_LENGTH\");\n        for (uint256 idx = 0; idx < len; idx++) {\n            // Check pendingRefs that exceeded pendingDuration\n            if (pendingRefReady(symbols[idx])) {\n                RefData memory pendingRef = pendingRefs[symbols[idx]];\n\n                // Use pendingRefs to update refs\n                refs[symbols[idx]] = pendingRef;\n\n                emit RefDataUpdate(\n                    symbols[idx],\n                    refs[symbols[idx]].rate,\n                    refs[symbols[idx]].resolveTime,\n                    refs[symbols[idx]].requestID\n                );\n\n                // refs[symbols[idx]] = pendingRefs[symbols[idx]];\n                if (resolveTimes[idx] > pendingRef.resolveTime) {\n                    // updated pendingRefs using the input arguments\n                    pendingRefs[symbols[idx]] = RefData({\n                        rate: rates[idx],\n                        resolveTime: resolveTimes[idx],\n                        relayTime: uint64(block.timestamp),\n                        requestID: requestIDs[idx]\n                    });\n                    emit PendingRefDataUpdate(\n                        symbols[idx],\n                        rates[idx],\n                        resolveTimes[idx],\n                        requestIDs[idx]\n                    );\n                }\n            }\n        }\n    }\n\n    /// @notice Relay and save a set of price data to the contract using proof from Bandchain\n    /// @param proof Aggregator oralce script request proof from BandChain\n    function relayWithProof(bytes calldata proof) external {\n        (IBridge.RequestPacket memory req, IBridge.ResponsePacket memory res) =\n            bridge.relayAndVerify(proof);\n\n        // Check request ansCount >= specified\n        require(res.ansCount >= ansCount, \"MIN_ANS_COUNT_NOT_REACHED\");\n\n        // Check request askCount is the same as specified\n        require(req.askCount == askCount, \"ASK_COUNT_NOT_MATCHED\");\n\n        // Check request oracle script is in oracleScriptIDs\n        require(\n            checkOracleScriptID(req.oracleScriptID),\n            \"UNEXPECTED_ORACLE_SCRIPT_ID\"\n        );\n\n        // Decode request parameters and result fields\n        StdReferenceDecoder.Params memory params =\n            StdReferenceDecoder.decodeParams(req.params);\n        StdReferenceDecoder.Result memory result =\n            StdReferenceDecoder.decodeResult(res.result);\n\n        for (uint256 idx = 0; idx < params.symbols.length; idx++) {\n            string memory symbol = params.symbols[idx];\n            if (res.resolveTime > verifiedRefs[symbol].resolveTime) {\n                uint64 rate =\n                    uint64(\n                        uint256(result.rates[idx]).mul(1e9).div(\n                            uint256(params.multiplier)\n                        )\n                    );\n\n                // Update pendingRefs using the request result\n                verifiedRefs[symbol] = RefData({\n                    rate: rate,\n                    resolveTime: res.resolveTime,\n                    relayTime: uint64(block.timestamp),\n                    requestID: res.requestID\n                });\n\n                emit VerifiedRefDataUpdate(\n                    symbol,\n                    rate,\n                    res.resolveTime,\n                    res.requestID\n                );\n            }\n        }\n    }\n\n    /// @notice Returns the price data for the given base/quote pair. Revert if not available.\n    /// @param base the base symbol of the token pair to query\n    /// @param quote the quote symbol of the token pair to query\n    function getReferenceData(string memory base, string memory quote)\n        public\n        view\n        override\n        returns (ReferenceData memory)\n    {\n        (uint256 baseRate, uint256 baseLastUpdate) = getRefData(base);\n        (uint256 quoteRate, uint256 quoteLastUpdate) = getRefData(quote);\n        return\n            ReferenceData({\n                rate: (baseRate * 1e18) / quoteRate,\n                lastUpdatedBase: baseLastUpdate,\n                lastUpdatedQuote: quoteLastUpdate\n            });\n    }\n\n    /// @notice Get the latest usable price data of a token\n    /// @param symbol the symbol of the token whose price to query\n    function getRefData(string memory symbol)\n        public\n        view\n        returns (uint256 rate, uint256 lastUpdate)\n    {\n        if (keccak256(bytes(symbol)) == keccak256(bytes(\"USD\"))) {\n            return (1e9, block.timestamp);\n        }\n\n        RefData storage verifiedRefData = verifiedRefs[symbol];\n\n        // If relayer is currently not trusted, use data from verifiedRefs\n        if (!trustRelayer) {\n            require(\n                verifiedRefData.resolveTime > 0,\n                \"VERIFIED_REFS_DATA_NOT_AVAILABLE\"\n            );\n            return (\n                uint256(verifiedRefData.rate),\n                uint256(verifiedRefData.resolveTime)\n            );\n        }\n\n        RefData storage refData = refs[symbol];\n        RefData storage pendingRefData = pendingRefs[symbol];\n\n        RefData memory candidateRef;\n\n        // Use pendingRefs as candidate source if resolveTime is older than pendingDuration\n        if (pendingRefReady(symbol)) {\n            candidateRef = pendingRefs[symbol];\n        } else {\n            candidateRef = refs[symbol];\n        }\n\n        // Compare resolveTime between candidateRefs and verifiedRefs\n        // and use the newer one\n        if (verifiedRefs[symbol].resolveTime > candidateRef.resolveTime) {\n            candidateRef = verifiedRefs[symbol];\n        }\n\n        require(\n            candidateRef.resolveTime > 0,\n            \"CANDIDATE_REFS_DATA_NOT_AVAILABLE\"\n        );\n        return (uint256(candidateRef.rate), uint256(candidateRef.resolveTime));\n    }\n\n    /// @notice Check if the input oracle script ID is in the list of valid IDs\n    /// @param oid The oracle script ID to query the validity of\n    function checkOracleScriptID(uint64 oid) internal view returns (bool) {\n        for (uint256 idx = 0; idx < oracleScriptIDs.length; idx++) {\n            if (oracleScriptIDs[idx] == oid) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /// @notice Check if a token data in pendingRef is ready to be used\n    /// @param symbol The symbol of the token to query the status of\n    function pendingRefReady(string memory symbol) public view returns (bool) {\n        return (uint64(block.timestamp) - pendingRefs[symbol].resolveTime >=\n            pendingDuration &&\n            uint64(block.timestamp) - pendingRefs[symbol].relayTime >=\n            pendingDuration);\n    }\n}\n"
        },
        "./contracts/stdreference/StdReferenceBasic.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"../../interfaces/stdreference/IStdReference.sol\";\n\n/// @title BandChain StdReferenceBasic\n/// @author Band Protocol Team\ncontract StdReferenceBasic is AccessControl, StdReferenceBase {\n    event RefDataUpdate(\n        string symbol,\n        uint64 rate,\n        uint64 resolveTime,\n        uint64 requestID\n    );\n\n    struct RefData {\n        uint64 rate; // USD-rate, multiplied by 1e9.\n        uint64 resolveTime; // UNIX epoch when data is last resolved.\n        uint64 requestID; // BandChain request identifier for this data.\n    }\n\n    /// Mapping from token symbol to ref data\n    mapping(string => RefData) public refs;\n\n    bytes32 public constant RELAYER_ROLE = keccak256(\"RELAYER_ROLE\");\n\n    constructor() public {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(RELAYER_ROLE, msg.sender);\n    }\n\n    /// @notice Relay and save a set of price data to the contract\n    /// @dev All of the lists must be of equal length\n    /// @param symbols A list of symbols whose data is being relayed in this function call\n    /// @param rates A list of the rates associated with each symbol\n    /// @param resolveTimes A list of timestamps of when the rate data was retrieved\n    /// @param requestIDs A list of BandChain request IDs in which the rate data was retrieved\n    function relay(\n        string[] memory symbols,\n        uint64[] memory rates,\n        uint64[] memory resolveTimes,\n        uint64[] memory requestIDs\n    ) external {\n        require(hasRole(RELAYER_ROLE, msg.sender), \"NOTARELAYER\");\n        uint256 len = symbols.length;\n        require(rates.length == len, \"BADRATESLENGTH\");\n        require(resolveTimes.length == len, \"BADRESOLVETIMESLENGTH\");\n        require(requestIDs.length == len, \"BADREQUESTIDSLENGTH\");\n        for (uint256 idx = 0; idx < len; idx++) {\n            refs[symbols[idx]] = RefData({\n                rate: rates[idx],\n                resolveTime: resolveTimes[idx],\n                requestID: requestIDs[idx]\n            });\n            emit RefDataUpdate(\n                symbols[idx],\n                rates[idx],\n                resolveTimes[idx],\n                requestIDs[idx]\n            );\n        }\n    }\n\n    /// @notice Returns the price data for the given base/quote pair. Revert if not available.\n    /// @param base the base symbol of the token pair to query\n    /// @param quote the quote symbol of the token pair to query\n    function getReferenceData(string memory base, string memory quote)\n        public\n        view\n        override\n        returns (ReferenceData memory)\n    {\n        (uint256 baseRate, uint256 baseLastUpdate) = _getRefData(base);\n        (uint256 quoteRate, uint256 quoteLastUpdate) = _getRefData(quote);\n        return\n            ReferenceData({\n                rate: (baseRate * 1e18) / quoteRate,\n                lastUpdatedBase: baseLastUpdate,\n                lastUpdatedQuote: quoteLastUpdate\n            });\n    }\n\n    /// @notice Get the price data of a token\n    /// @param symbol the symbol of the token whose price to query\n    function _getRefData(string memory symbol)\n        internal\n        view\n        returns (uint256 rate, uint256 lastUpdate)\n    {\n        if (keccak256(bytes(symbol)) == keccak256(bytes(\"USD\"))) {\n            return (1e9, block.timestamp);\n        }\n        RefData storage refData = refs[symbol];\n        require(refData.resolveTime > 0, \"REFDATANOTAVAILABLE\");\n        return (uint256(refData.rate), uint256(refData.resolveTime));\n    }\n}\n"
        },
        "./contracts/vrf/library/VRFDecoder.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport {Obi} from \"../../obi/Obi.sol\";\n\n/// @title ParamsDecoder library\n/// @notice Library for decoding the OBI-encoded input parameters of a VRF data request\nlibrary VRFDecoder {\n    using Obi for Obi.Data;\n\n    struct Params {\n        string seed;\n        uint64 time;\n    }\n\n    struct Result {\n        bytes hash;\n    }\n\n    /// @notice Decodes the encoded request input parameters\n    /// @param encodedParams Encoded paramter data\n    function decodeParams(bytes memory encodedParams)\n        internal\n        pure\n        returns (Params memory params)\n    {\n        Obi.Data memory decoder = Obi.from(encodedParams);\n        params.seed = decoder.decodeString();\n        params.time = decoder.decodeU64();\n        require(decoder.finished(), \"DATA_DECODE_NOT_FINISHED\");\n    }\n\n    /// @notice Decodes the encoded data request response result\n    /// @param encodedResult Encoded result data\n    function decodeResult(bytes memory encodedResult)\n        internal\n        pure\n        returns (Result memory result)\n    {\n        Obi.Data memory decoder = Obi.from(encodedResult);\n        result.hash = decoder.decodeBytes();\n        require(decoder.finished(), \"DATA_DECODE_NOT_FINISHED\");\n    }\n}\n"
        },
        "./contracts/vrf/BandVRF.sol": {
            "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport {IBridge} from \"../../interfaces/bridge/IBridge.sol\";\nimport {Obi} from \"../obi/Obi.sol\";\nimport {VRFDecoder} from \"./library/VRFDecoder.sol\";\n\n/// @title BandVRF contract\n/// @notice Contract for working with BandChain's verifiable random function feature\ncontract BandVRF {\n    using Obi for Obi.Data;\n    IBridge private _bridge;\n\n    /// @notice BandVRF constructor\n    /// @param bridge The address of Band's Bridge contract\n    constructor(IBridge bridge) public {\n        _bridge = bridge;\n    }\n\n    /// @notice Validate the input proof and returns the corresponding seed, timestamp, and random hash\n    /// @dev The function expects a proof byte corresponding to a VRF data request on BandChain.\n    /// It then uses Band's bridge contract to verify the correctness of the proof and decodes\n    /// the corresponding request and response packets\n    /// Finally, the function decodes the packets and returns the seed phrase, timestamp,\n    /// and result random hash\n    /// @param proof The proof bytes returned as a result of a data request on BandChain\n    function getRandomHash(bytes calldata proof)\n        external\n        returns (\n            string memory seed,\n            uint64 time,\n            bytes memory hash\n        )\n    {\n        // Verify input proof using the bridge contract's relayAndVerify method\n        (\n            IBridge.RequestPacket memory req,\n            IBridge.ResponsePacket memory res\n        ) = _bridge.relayAndVerify(proof);\n\n        // Decode the returned request's input parameters and response parameters\n        VRFDecoder.Params memory params = VRFDecoder.decodeParams(req.params);\n        VRFDecoder.Result memory result = VRFDecoder.decodeResult(res.result);\n\n        return (params.seed, params.time, result.hash);\n    }\n}\n"
        },
        "@openzeppelin/contracts/math/SafeMath.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
        },
        "@openzeppelin/contracts/access/Ownable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
        },
        "@openzeppelin/contracts/GSN/Context.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
        },
        "@openzeppelin/contracts/access/AccessControl.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../utils/EnumerableSet.sol\";\nimport \"../utils/Address.sol\";\nimport \"../GSN/Context.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Address for address;\n\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members.contains(account);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n        return _roles[role].members.at(index);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (_roles[role].members.add(account)) {\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (_roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/EnumerableSet.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\n * (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint256(_at(set._inner, index)));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
        },
        "@openzeppelin/contracts/utils/Address.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
        }
    },
    "settings": {
        "metadata": {
            "useLiteralContent": true
        },
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ],
                "": [
                    "id",
                    "ast"
                ]
            }
        }
    }
}